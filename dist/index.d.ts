import { AxiosPromise } from 'axios';
interface optionsObject {
    /**
     * Autogenerated value
     *
     * @type {number}
     * @memberof optionsObject
     */
    marked: number;
}
interface commentInterface {
    /**
     *Comment text
     *
     * @type {string}
     * @memberof commentObject
     */
    text: string;
    /**
     *Username
     *
     * @type {string}
     * @memberof commentObject
     */
    username: string;
    /**
     *Link of the avatar
     *
     * @type {string}
     * @memberof commentObject
     */
    avatar: string;
}
interface saramObject {
    /**
     *Auto generated id
     *
     * @type {string}
     * @memberof saramObject
     */
    id: string;
    /**
     *Type of output. Valid types are file, stdout, script, dump, tool and image
     *
     * @type {string}
     * @memberof saramObject
     */
    type: string;
    /**
     * Output of command
     *
     * @type {string}
     * @memberof saramObject
     */
    output: string;
    /**
     * Command to run
     *
     * @type {string}
     * @memberof saramObject
     */
    command: string;
    /**
     * Username. Sets from `.saram.conf` file
     *
     * @type {string}
     * @memberof saramObject
     */
    user: string;
    /**
     *The comments object. Object includes username, text and avatar
     *
     * @type {Array<commentInterface>}
     * @memberof saramObject
     */
    comment: Array<commentInterface>;
    /**
     * Options object
     *
     * @type {optionsObject}
     * @memberof saramObject
     */
    options: optionsObject;
    /**
     * The time string. use `new Date().toUTCString()`
     *
     * @type {string}
     * @memberof saramObject
     */
    time: string;
}
interface methodTypes {
    /**
     * Optional comment string
     *
     * @type {string}
     * @memberof methodTypes
     */
    comment?: string;
    /**
     * Optional script name
     *
     * @type {string}
     * @memberof methodTypes
     */
    scriptName?: string;
}
/**
 * The main class for Saram. token and user values are required.
 * If the .saram.conf file is not found in the home directory, it
 * will throw an error.
 */
declare class Saram {
    private token;
    avatar: string;
    key: string;
    user: string;
    configPath: string;
    baseUrl: string;
    url: string;
    saramObject: saramObject;
    /**
     * Token of the entry to work with
     *
     * @type {string}
     * @memberof init
     */
    constructor(token: string);
    /**
     * Strips out ansii color escape codes from stdout
     */
    private cleanOutput;
    /**
     * Reads the contents of the whole script this method is called
     * in and makes it available to send to the Saram server
     *
     * @param {methodTypes} [params={}]
     * @returns {Saram}
     */
    readScriptSelf: (params?: methodTypes) => Saram;
    /**
     * Method that returns the whole file of the file it is called in.
     *
     * @param {string} filePath A valid file path to read. Will not work with binary files
     * @param {methodTypes} [params={}] Optionally set a comment with `comment` param
     * @returns {Saram}
     */
    readFileContent: (filePath: string, params?: methodTypes) => Saram;
    /**
     * Function will send the variable of a JS/TS file to the server
     *
     * @param {*} variable The output from any script variable
     * @param {methodTypes} [params={}] Optionally set a comment with `comment` param
     * @returns {Saram}
     */
    variableOutput: (variable: any, params?: methodTypes) => Saram;
    /**
     * Send the output of a command line command to the server
     *
     * @param {string} command The command to run
     * @param {methodTypes} [params={}] Optionally set a comment with `comment` param
     * @returns {Saram}
     */
    runCommand: (command: string, params?: methodTypes) => Saram;
    /**
   * Sends the value of saramObject to the Saram server
   */
    sendToServer: () => void;
    /**
   * Alias for sendToServer
     *
     * @memberof Saram
     */
    send: () => void;
}
/**
 * This class is intended to create the local `.saram.conf` file
 * which all Saram extentions/modules etc relies on.
 */
declare class SaramInit {
    private apiKey;
    private local?;
    private base_url?;
    private configPath;
    /**
     *Creates an instance of SaramInit.
     * @param {string} apiKey a valid api key
     * @param {boolean} [local] set to true to use localhost as base url
     * @param {string} [base_url] set the base url. Otherwise the default Saram url is used
     */
    constructor({ apiKey, local, base_url }: {
        apiKey: string;
        local?: boolean;
        base_url?: string;
    });
    /**
     * The init method will create a `.saram.conf` file in the users
     * home directory using a valid API key and username.
     *
     * @memberof SaramInit
     */
    init(): void;
}
interface CreateNewSection {
    /**
     *The token for the entry. Each entry has a unique token
     *
     * @type {string}
     * @memberof CreateNewSection
     */
    token: string;
    /**
     * What type of output is it? Valid types are
     * file, script, dump, stdout, tool and image
     *
     * @type {string}
     * @memberof CreateNewSection
     */
    type: string;
    /**
     * The output that a command generates. This could
     * also be the content of a script or file
     *
     * @type {string}
     * @memberof CreateNewSection
     */
    output: string;
    /**
     * The command that was run. This could also be a file name
     *
     * @type {string}
     * @memberof CreateNewSection
     */
    command: string;
    /**
     * Comment to add. Optional
     *
     * @type {Array<string>}
     * @memberof CreateNewSection
     */
    comment?: Array<commentInterface>;
}
/**
 * This class makes the whole API for Saram available.
 */
declare class SaramAPI extends Saram {
    private headers;
    private request;
    private apiUrl;
    private validTypes;
    private validCategories;
    /**
     *Creates an instance of SaramAPI.
     * @memberof SaramAPI
     */
    constructor();
    /**
     * Private method that generates a valid token
     */
    private _generateToken;
    /**
     * Gets an array of all the valid entries
     *
     * @returns {AxiosPromise} An Axios promise
     */
    getAllEntries: () => AxiosPromise<any>;
    /**
     * Gets all the data associated with a single entry
     *
     * @param {string} token A valid entry token
     * @returns {AxiosPromise} An Axios promise
     */
    getEntry: (token: string) => AxiosPromise<any>;
    /**
     * Delete an entry entirely
     *
     * @param {string} token A valid entry token
     * @returns {AxiosPromise} An Axios promise
     */
    deleteEntry: (token: string) => AxiosPromise<any>;
    /**
     *
     * Create a new section. This will add to the existing entry.
     *
     * @param {CreateNewSection} data
     * @returns {AxiosPromise} An Axios promise
     */
    createNewSection: (data: CreateNewSection) => AxiosPromise<any>;
    /**
     * Add a comment to an existing section
     *
     * @param {string} token The token for the entry
     * @param {string} dataid The dataid for the section
     * @param {string} comment Comment to add
     * @returns {AxiosPromise} An Axios promise
     */
    addComment: (token: string, dataid: string, comment: string) => AxiosPromise<any>;
    /**
     * Delete a section. This will delete a single section in an entry
     *
     * @param {string} token A valid toekn for the entry
     * @param {string} dataid The dataid of the section to delete
     * @returns {AxiosPromise} An Axios promise
     */
    deleteSection: (token: string, dataid: string) => AxiosPromise<any>;
    /**
     * Create a new entry. This is a whole new entry to work with
     *
     * @param {string} title The title of the entry
     * @param {string} category A valid category
     * @param {string} [slackLink] Optional Slack or reference link
     * @returns {AxiosPromise} An Axios promise
     */
    createNewEntry: (title: string, category: string, slackLink?: string | undefined) => AxiosPromise<any>;
    /**
     * Reset the API key
     *
     * @param {string} oldApiKey The current API key
     * @param {string} username The current username
     * @returns {AxiosPromise}
     */
    resetApiKey: (oldApiKey: string, username: string) => AxiosPromise<any>;
    /**
     * Changes the username. Accepts a valid API key, a valid
     * current username and the new username. Returns a new username
     *
     * @param {string} apiKey A valid API key
     * @param {string} oldUserName The previous username
     * @param {string} newUserName The new username
     * @returns {AxiosPromise} An Axios promise
     */
    changeUserName: (apiKey: string, oldUserName: string, newUserName: string) => AxiosPromise<any>;
    /**
     * Validates an API key, and returns the key and associated
     * username on success.
     *
     * @param {string} apiKey A valid API key
     * @returns {AxiosPromise} an Axios promise
     */
    validateApiKey: (apiKey: string) => AxiosPromise<any>;
    /**
     * Generate a valid token. These can be used for testing
     * or for other methods that require a valid token
     *
     * @param {string} title The title of the section/challenge
     * @returns {string} a valid token
     */
    getValidToken: (title: string) => string;
}
export { Saram, SaramInit, SaramAPI };
